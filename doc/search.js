window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "rom-tools-and-workflows", "modulename": "rom-tools-and-workflows", "kind": "module", "doc": "<p>The ROM tools and workflows Python library comprises a set of algorithms for constructing and exploiting ROMs that rely on <em>abstract base classes</em> that encapsulate all the information needed to run a given algorithm. The philosophy is that, for any given application, the user simply needs to \"fill out\" a class that meets the required API of the abstract base class. Once this class is complete, the user gains access to all of our existing algorithms.</p>\n\n<p>What is in the rom-tools-and-workflows library?</p>\n\n<p>Algorithms:</p>\n\n<ul>\n<li>Trial space computation:\n<ul>\n<li>Reduced-basis methods</li>\n<li>Proper orthogonal decomposition\n<ul>\n<li>Algorithms are all compatible with basis scaling, basis splitting for multistate problems, and orthogonalization in different inner products</li>\n</ul></li>\n</ul></li>\n<li>Workflows for ROM construction and ROM exploitation:\n<ul>\n<li>ROM construction via reduced-basis greedy (RB-Greedy)</li>\n<li>ROM/FOM exploitation via sampling</li>\n<li>ROM/FOM exploitation via Dakota-driven sampling</li>\n</ul></li>\n</ul>\n\n<p>Abstract base classes include:</p>\n\n<ul>\n<li>AbstractSnapshotData\n<ul>\n<li>This class defines the minimum API requirements for a \"snapshot_data\" class that will be used in the construction of a trial space.</li>\n</ul></li>\n<li>AbstractTrialSpace\n<ul>\n<li>This class defines the minimum API requirements for a trial space</li>\n<li>Constructing a trial space relies on utilities like truncaters, orthogonalizers, etc. Abstract classes, and concrete implementations, exist for:\n<ul>\n<li>orthogonalizers</li>\n<li>scalers</li>\n<li>shifters</li>\n<li>splitters</li>\n<li>truncaters</li>\n</ul></li>\n</ul></li>\n<li>AbstractParameterSpace\n<ul>\n<li>This class defines the minimum API of a parameter space. These parameter spaces are used in workflows for running/building ROMs</li>\n</ul></li>\n<li>Abstract couplers for greedy sampling, sampling, and coupling to Dakota.</li>\n</ul>\n"}, {"fullname": "rom-tools-and-workflows.romtools", "modulename": "rom-tools-and-workflows.romtools", "kind": "module", "doc": "<p>The core_implementations module contains the abstract interfaces and functions required for, e.g., </p>\n\n<ul>\n<li>Constructing parameter spaces</li>\n<li>Constructing a snapshot data class</li>\n<li>Constructing trial spaces</li>\n<li>Constructing and exploiting ROMs via outer loop workflows</li>\n</ul>\n"}, {"fullname": "rom-tools-and-workflows.romtools.snapshot_data", "modulename": "rom-tools-and-workflows.romtools.snapshot_data", "kind": "module", "doc": "<p>Most ROM formulations require access to so-called snapshot data to construct a reduced trial space. A snapshot is typically a\nsolution to a full-order model. As an example, consider a (discretized) parameterized PDE defined by</p>\n\n<p>$$\\boldsymbol r( \\mathbf{u}(\\boldsymbol \\mu);\\boldsymbol \\mu)$$</p>\n\n<p>where $\\boldsymbol r$ is the residual operator, $\\mathbf{u}$ is the state, and $\\boldsymbol \\mu$ are system parameters.\nSuppose we have solved the PDE for a set of $M$ training parameters to obtain the so-called snapshot matrix</p>\n\n<p>$$\\mathbf{S} = \\begin{bmatrix}\n\\mathbf{u} (\\boldsymbol \\mu_1 ) &amp;\n\\cdots &amp;\n\\mathbf{u}(\\boldsymbol \\mu_M)\n\\end{bmatrix}\n$$</p>\n\n<p>The SnapshotData class encapsulates the information contained in set of snapshots, and is the main class used in the construction of trial spaces</p>\n"}, {"fullname": "rom-tools-and-workflows.romtools.snapshot_data.AbstractSnapshotData", "modulename": "rom-tools-and-workflows.romtools.snapshot_data", "qualname": "AbstractSnapshotData", "kind": "class", "doc": "<p>Abstract base class for snapshot data</p>\n", "bases": "abc.ABC"}, {"fullname": "rom-tools-and-workflows.romtools.snapshot_data.AbstractSnapshotData.getSnapshotsAsArray", "modulename": "rom-tools-and-workflows.romtools.snapshot_data", "qualname": "AbstractSnapshotData.getSnapshotsAsArray", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.snapshot_data.AbstractSnapshotData.getSnapshotsAsListOfArrays", "modulename": "rom-tools-and-workflows.romtools.snapshot_data", "qualname": "AbstractSnapshotData.getSnapshotsAsListOfArrays", "kind": "function", "doc": "<p>Return snapshot matrix as list of arrays\n(e.g., each element in the list could be its own snapshot matrix)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.snapshot_data.AbstractSnapshotData.getMeshGids", "modulename": "rom-tools-and-workflows.romtools.snapshot_data", "qualname": "AbstractSnapshotData.getMeshGids", "kind": "function", "doc": "<p>Returns global ids associated with mesh points (used for hyper-reduction)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.snapshot_data.AbstractSnapshotData.getVariableNames", "modulename": "rom-tools-and-workflows.romtools.snapshot_data", "qualname": "AbstractSnapshotData.getVariableNames", "kind": "function", "doc": "<p>Returns the names of different state variables</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.snapshot_data.AbstractSnapshotData.getNumVars", "modulename": "rom-tools-and-workflows.romtools.snapshot_data", "qualname": "AbstractSnapshotData.getNumVars", "kind": "function", "doc": "<p>Returns the number of state variables\n(e.g., 5 for the compressible Navier--Stokes equations in 3 dimensions)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.snapshot_data.listOfSnapshotsToArray", "modulename": "rom-tools-and-workflows.romtools.snapshot_data", "qualname": "listOfSnapshotsToArray", "kind": "function", "doc": "<p>Helper function to move snapshot list into a matrix</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">list_of_snapshots</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space", "modulename": "rom-tools-and-workflows.romtools.trial_space", "kind": "module", "doc": "<h1 id=\"trial-space-overview\">Trial space overview</h1>\n\n<p>A trial space is foundational to reduced-order models.\nIn a ROM, we restrict a high-dimensional state to live within a low-dimensional trial space.\nMathematically, for a \"FOM\" vector $\\mathbf{u} \\in \\mathbb{R}^N$, we represent this as\n$$\\mathbf{u} \\approx \\tilde{\\mathbf{u}} \\in \\mathcal{V}$$\nwhere $\\mathcal{V}$ with\n$\\text{dim}(\\mathcal{V}) = K \\le N$\nis the trial space. Formally, we can describe this low-dimensional representation with a basis and an offine offset,\n$$\\tilde{\\mathbf{u}}  = \\boldsymbol \\Phi \\hat{\\mathbf{u}} + \\mathbf{u}_{\\mathrm{shift}}$$\nwhere $\\boldsymbol \\Phi \\in \\mathbb{R}^{N       imes K}$ is the basis matrix,\n$\\hat{\\mathbf{u}} \\in \\mathbb{R}^{K}$ are the reduced, or generalized coordinates,\n$\\mathbf{u}_{\\mathrm{shift}} \\in \\mathbb{R}^N$ is the shift vector (or affine offset), and, by definition,\n$\\mathcal{V} \\equiv \\mathrm{range}(\\boldsymbol \\Phi) + \\mathbf{u}_{\\mathrm{shift}}$.</p>\n\n<p>The trial_space class encapsulates the information of an affine trial space, $\\mathcal{V}$,\nby virtue of providing access to a basis matrix, a shift vector, and the dimensionality of the trial space.</p>\n"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space.AbstractTrialSpace", "modulename": "rom-tools-and-workflows.romtools.trial_space", "qualname": "AbstractTrialSpace", "kind": "class", "doc": "<p>Abstract implementation</p>\n", "bases": "abc.ABC"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space.AbstractTrialSpace.getDimension", "modulename": "rom-tools-and-workflows.romtools.trial_space", "qualname": "AbstractTrialSpace.getDimension", "kind": "function", "doc": "<p>Returns the dimension of the trial space</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space.AbstractTrialSpace.getShiftVector", "modulename": "rom-tools-and-workflows.romtools.trial_space", "qualname": "AbstractTrialSpace.getShiftVector", "kind": "function", "doc": "<p>Returns the shift vector</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space.AbstractTrialSpace.getBasis", "modulename": "rom-tools-and-workflows.romtools.trial_space", "qualname": "AbstractTrialSpace.getBasis", "kind": "function", "doc": "<p>Returns the basis</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space.DictionaryTrialSpace", "modulename": "rom-tools-and-workflows.romtools.trial_space", "qualname": "DictionaryTrialSpace", "kind": "class", "doc": "<h2 id=\"reduced-basis-trial-space-no-truncation\">Reduced basis trial space (no truncation).</h2>\n\n<p>Given a snapshot matrix $\\mathbf{S}$, we set the basis to be</p>\n\n<p>$$\\boldsymbol \\Phi = \\mathrm{orthogonalize}(\\mathrm{split}(\\mathbf{S} - \\mathbf{u}_{\\mathrm{shift}}))$$</p>\n\n<p>where the orthogonalization, splitting, and shifts are defined by their respective classes</p>\n", "bases": "AbstractTrialSpace"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space.DictionaryTrialSpace.__init__", "modulename": "rom-tools-and-workflows.romtools.trial_space", "qualname": "DictionaryTrialSpace.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">snapshot_data</span>, </span><span class=\"param\"><span class=\"n\">shifter</span>, </span><span class=\"param\"><span class=\"n\">splitter</span>, </span><span class=\"param\"><span class=\"n\">orthogonalizer</span></span>)</span>"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space.DictionaryTrialSpace.getDimension", "modulename": "rom-tools-and-workflows.romtools.trial_space", "qualname": "DictionaryTrialSpace.getDimension", "kind": "function", "doc": "<p>Returns dimension of trial space</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space.DictionaryTrialSpace.getShiftVector", "modulename": "rom-tools-and-workflows.romtools.trial_space", "qualname": "DictionaryTrialSpace.getShiftVector", "kind": "function", "doc": "<p>Returns the shift vector</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space.DictionaryTrialSpace.getBasis", "modulename": "rom-tools-and-workflows.romtools.trial_space", "qualname": "DictionaryTrialSpace.getBasis", "kind": "function", "doc": "<p>Returns the basis</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space.TrialSpaceFromPOD", "modulename": "rom-tools-and-workflows.romtools.trial_space", "qualname": "TrialSpaceFromPOD", "kind": "class", "doc": "<h2 id=\"pod-trial-space-constructed-via-svd\">POD trial space (constructed via SVD).</h2>\n\n<p>Given a snapshot matrix $\\mathbf{S}$, we set the basis to be</p>\n\n<p>$$\\boldsymbol U = \\mathrm{SVD}(\\mathrm{split}(\\mathbf{S} - \\mathbf{u}_{\\mathrm{shift}})))$$\n$$\\boldsymbol \\Phi = \\mathrm{orthogonalize}(\\mathrm{truncate}( \\boldsymbol U ))$$</p>\n\n<p>where $\\boldsymbol U$ are the left singular vectors and the orthogonalization,\ntruncation, splitting, and shifts are defined by their respective classes.</p>\n\n<p>For truncation, we enable truncation based on a fixed dimension or the decay\nof singular values; please refer to the documentation for the truncater.</p>\n", "bases": "AbstractTrialSpace"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space.TrialSpaceFromPOD.__init__", "modulename": "rom-tools-and-workflows.romtools.trial_space", "qualname": "TrialSpaceFromPOD.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">snapshot_data</span><span class=\"p\">:</span> <span class=\"n\">romtools</span><span class=\"o\">.</span><span class=\"n\">snapshot_data</span><span class=\"o\">.</span><span class=\"n\">AbstractSnapshotData</span>,</span><span class=\"param\">\t<span class=\"n\">truncater</span><span class=\"p\">:</span> <span class=\"n\">romtools</span><span class=\"o\">.</span><span class=\"n\">trial_space_utils</span><span class=\"o\">.</span><span class=\"n\">truncater</span><span class=\"o\">.</span><span class=\"n\">AbstractTruncater</span>,</span><span class=\"param\">\t<span class=\"n\">shifter</span><span class=\"p\">:</span> <span class=\"n\">romtools</span><span class=\"o\">.</span><span class=\"n\">trial_space_utils</span><span class=\"o\">.</span><span class=\"n\">shifter</span><span class=\"o\">.</span><span class=\"n\">AbstractShifter</span>,</span><span class=\"param\">\t<span class=\"n\">splitter</span><span class=\"p\">:</span> <span class=\"n\">romtools</span><span class=\"o\">.</span><span class=\"n\">trial_space_utils</span><span class=\"o\">.</span><span class=\"n\">splitter</span><span class=\"o\">.</span><span class=\"n\">AbstractSplitter</span>,</span><span class=\"param\">\t<span class=\"n\">orthogonalizer</span><span class=\"p\">:</span> <span class=\"n\">romtools</span><span class=\"o\">.</span><span class=\"n\">trial_space_utils</span><span class=\"o\">.</span><span class=\"n\">orthogonalizer</span><span class=\"o\">.</span><span class=\"n\">AbstractOrthogonalizer</span></span>)</span>"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space.TrialSpaceFromPOD.getDimension", "modulename": "rom-tools-and-workflows.romtools.trial_space", "qualname": "TrialSpaceFromPOD.getDimension", "kind": "function", "doc": "<p>Returns dimension of trial space</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space.TrialSpaceFromPOD.getShiftVector", "modulename": "rom-tools-and-workflows.romtools.trial_space", "qualname": "TrialSpaceFromPOD.getShiftVector", "kind": "function", "doc": "<p>Returns the shift vector</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space.TrialSpaceFromPOD.getBasis", "modulename": "rom-tools-and-workflows.romtools.trial_space", "qualname": "TrialSpaceFromPOD.getBasis", "kind": "function", "doc": "<p>Returns the basis</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space.TrialSpaceFromScaledPOD", "modulename": "rom-tools-and-workflows.romtools.trial_space", "qualname": "TrialSpaceFromScaledPOD", "kind": "class", "doc": "<h2 id=\"pod-trial-space-constructed-via-scaled-svd\">POD trial space (constructed via scaled SVD).</h2>\n\n<p>Given a snapshot matrix $\\mathbf{S}$, we set the basis to be</p>\n\n<p>$$\\boldsymbol U = \\mathrm{SVD}(\\mathrm{split}(\\mathrm{prescale}(\\mathbf{S} - \\mathbf{u}_{\\mathrm{shift}})))$$\n$$\\boldsymbol \\Phi = \\mathrm{orthogonalize}(\\mathrm{postscale}(\\mathrm{truncate}( \\boldsymbol U )))$$</p>\n\n<p>where $\\boldsymbol U$ are the left singular vectors and the orthogonalization,\ntruncation, splitting, and shifts are defined by their respective classes.</p>\n\n<p>For truncation, we enable truncation based on a fixed dimension or the decay of singular values;\nplease refer to the documentation for the truncater.</p>\n", "bases": "AbstractTrialSpace"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space.TrialSpaceFromScaledPOD.__init__", "modulename": "rom-tools-and-workflows.romtools.trial_space", "qualname": "TrialSpaceFromScaledPOD.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">snapshot_data</span><span class=\"p\">:</span> <span class=\"n\">romtools</span><span class=\"o\">.</span><span class=\"n\">snapshot_data</span><span class=\"o\">.</span><span class=\"n\">AbstractSnapshotData</span>,</span><span class=\"param\">\t<span class=\"n\">truncater</span><span class=\"p\">:</span> <span class=\"n\">romtools</span><span class=\"o\">.</span><span class=\"n\">trial_space_utils</span><span class=\"o\">.</span><span class=\"n\">truncater</span><span class=\"o\">.</span><span class=\"n\">AbstractTruncater</span>,</span><span class=\"param\">\t<span class=\"n\">shifter</span><span class=\"p\">:</span> <span class=\"n\">romtools</span><span class=\"o\">.</span><span class=\"n\">trial_space_utils</span><span class=\"o\">.</span><span class=\"n\">shifter</span><span class=\"o\">.</span><span class=\"n\">AbstractShifter</span>,</span><span class=\"param\">\t<span class=\"n\">scaler</span><span class=\"p\">:</span> <span class=\"n\">romtools</span><span class=\"o\">.</span><span class=\"n\">trial_space_utils</span><span class=\"o\">.</span><span class=\"n\">scaler</span><span class=\"o\">.</span><span class=\"n\">AbstractScaler</span>,</span><span class=\"param\">\t<span class=\"n\">splitter</span><span class=\"p\">:</span> <span class=\"n\">romtools</span><span class=\"o\">.</span><span class=\"n\">trial_space_utils</span><span class=\"o\">.</span><span class=\"n\">splitter</span><span class=\"o\">.</span><span class=\"n\">AbstractSplitter</span>,</span><span class=\"param\">\t<span class=\"n\">orthogonalizer</span><span class=\"p\">:</span> <span class=\"n\">romtools</span><span class=\"o\">.</span><span class=\"n\">trial_space_utils</span><span class=\"o\">.</span><span class=\"n\">orthogonalizer</span><span class=\"o\">.</span><span class=\"n\">AbstractOrthogonalizer</span></span>)</span>"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space.TrialSpaceFromScaledPOD.getDimension", "modulename": "rom-tools-and-workflows.romtools.trial_space", "qualname": "TrialSpaceFromScaledPOD.getDimension", "kind": "function", "doc": "<p>Returns dimension of trial space</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space.TrialSpaceFromScaledPOD.getShiftVector", "modulename": "rom-tools-and-workflows.romtools.trial_space", "qualname": "TrialSpaceFromScaledPOD.getShiftVector", "kind": "function", "doc": "<p>Returns the shift vector</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space.TrialSpaceFromScaledPOD.getBasis", "modulename": "rom-tools-and-workflows.romtools.trial_space", "qualname": "TrialSpaceFromScaledPOD.getBasis", "kind": "function", "doc": "<p>Returns the basis</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils", "kind": "module", "doc": "<p>There are a number of ways to construct a trial space, including affine offsets, scaling, splitting, etc. \nThe trial_space_utils module provides these functionalities</p>\n"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.orthogonalizer", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.orthogonalizer", "kind": "module", "doc": "<p>The OrthogonalizerClass is used to orthogonalize a basis at the end of the construction of a trial space.\nSpecifically, given a basis\n$$\\boldsymbol \\Phi \\in \\mathbb{R}^{N \\times K},$$\nthe orthogonalizer will compute a new, orthogonalized basis $\\boldsymbol \\Phi_{*}$\nwhere\n$$\\boldsymbol \\Phi_{*}^T \\mathbf{W} \\boldsymbol \\Phi_{*} = \\mathbf{I}.$$\nIn the above, $\\mathbf{W}$ is a weighting matrix (typically the cell volumes).</p>\n"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.orthogonalizer.AbstractOrthogonalizer", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.orthogonalizer", "qualname": "AbstractOrthogonalizer", "kind": "class", "doc": "<p>Abstract base class</p>\n", "bases": "abc.ABC"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.orthogonalizer.NoOpOrthogonalizer", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.orthogonalizer", "qualname": "NoOpOrthogonalizer", "kind": "class", "doc": "<p>No op class (doesn't do anything)</p>\n", "bases": "AbstractOrthogonalizer"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.orthogonalizer.EuclideanL2Orthogonalizer", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.orthogonalizer", "qualname": "EuclideanL2Orthogonalizer", "kind": "class", "doc": "<p>Orthogonalizes the basis in the standard Euclidean L2 inner product, i.e., the output basis will satisfy\n$$\\boldsymbol \\Phi_{*}^T \\boldsymbol \\Phi_{*} = \\mathbf{I}.$$</p>\n", "bases": "AbstractOrthogonalizer"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.orthogonalizer.EuclideanVectorWeightedL2Orthogonalizer", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.orthogonalizer", "qualname": "EuclideanVectorWeightedL2Orthogonalizer", "kind": "class", "doc": "<p>Orthogonalizes the basis in vector-weighted Euclidean L2 inner product, i.e., the output basis will satisfy\n$$\\boldsymbol \\Phi_{*}^T \\mathrm{diag}(\\mathbf{w})\\boldsymbol \\Phi_{*} = \\mathbf{I},$$\nwhere $\\mathbf{w}$ is the weighting vector. Typically, this inner product is used for orthogonalizing with respect to cell volumes</p>\n", "bases": "AbstractOrthogonalizer"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.orthogonalizer.EuclideanVectorWeightedL2Orthogonalizer.__init__", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.orthogonalizer", "qualname": "EuclideanVectorWeightedL2Orthogonalizer.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">weighting_vector</span></span>)</span>"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.outputter", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.outputter", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.outputter.npz_output", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.outputter", "qualname": "npz_output", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">trial_space</span><span class=\"p\">:</span> <span class=\"n\">romtools</span><span class=\"o\">.</span><span class=\"n\">trial_space</span><span class=\"o\">.</span><span class=\"n\">AbstractTrialSpace</span>,</span><span class=\"param\">\t<span class=\"n\">compress</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.outputter.hdf5_output", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.outputter", "qualname": "hdf5_output", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">output_filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">trial_space</span><span class=\"p\">:</span> <span class=\"n\">romtools</span><span class=\"o\">.</span><span class=\"n\">trial_space</span><span class=\"o\">.</span><span class=\"n\">AbstractTrialSpace</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.outputter.exodus_ouput", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.outputter", "qualname": "exodus_ouput", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">output_filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">mesh_filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">trial_space</span><span class=\"p\">:</span> <span class=\"n\">romtools</span><span class=\"o\">.</span><span class=\"n\">trial_space</span><span class=\"o\">.</span><span class=\"n\">AbstractTrialSpace</span>,</span><span class=\"param\">\t<span class=\"n\">var_names</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "kind": "module", "doc": "<p>The scaler class is used to performed scaled POD.</p>\n\n<p><em>What is scaled POD, and why would I do it?</em></p>\n\n<p>Standard POD computes a basis that minimizes the projection error in a standard Euclidean $\\ell^2$ inner product, i.e.,\nfor a snapshot matrix $\\mathbf{S}$, POD computes the basis by solving the minimization problem (assuming no affine offset)\n$$ \\boldsymbol \\Phi = \\underset{ \\boldsymbol \\Phi_{*} \\in \\mathbb{R}^{N \\times K} | \\boldsymbol \\Phi_{*}^T \\boldsymbol \\Phi_{*} = \\mathbf{I}}{ \\mathrm{arg \\; min} } \\| \\Phi_{*} \\Phi_{*}^T \\mathbf{S} - \\mathbf{S} \\|_2.$$\nIn this minimization problem, errors are measured in a standard $\\ell^2$ norm.\nFor most practical applications, where our snapshot matrix involves variables of different scales,\nthis norm does not make sense (both intuitively, and on dimensional grounds).\nAs a practical example, consider fluid dynamics where the total energy is orders of magnitude larger than the density.</p>\n\n<p>One of the most common approaches for mitigating this issue is to perform scaled POD.\nIn scaled POD, we solve a minimization problem on a scaled snapshot matrix.\nDefining $\\mathbf{S}_{*} = \\mathbf{W}^{-1} \\mathbf{S}$, where $\\mathbf{W}$ is a weighting matrix\n(e.g., a diagonal matrix containing the max absolute value of each state variable),\nwe compute the basis as the solution to the minimization problem\n$$ \\boldsymbol \\Phi = \\mathbf{W} \\underset{ \\boldsymbol \\Phi_{*} \\in \\mathbb{R}^{N \\times K} | \\boldsymbol \\Phi_{*}^T \\boldsymbol \\Phi_{*} = \\mathbf{I}}{ \\mathrm{arg \\; min} } \\| \\Phi_{*} \\Phi_{*}^T \\mathbf{S}_{*} - \\mathbf{S}_{*} \\|_2.$$</p>\n\n<p>The Scaler encapsulates this information</p>\n"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.scaler.AbstractScaler", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "qualname": "AbstractScaler", "kind": "class", "doc": "<p>Abstract base class</p>\n", "bases": "abc.ABC"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.scaler.AbstractScaler.preScaling", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "qualname": "AbstractScaler.preScaling", "kind": "function", "doc": "<p>Scales the snapshot matrix before performing SVD</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">my_array</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.scaler.AbstractScaler.postScaling", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "qualname": "AbstractScaler.postScaling", "kind": "function", "doc": "<p>Scales the left singular vectors after performing SVD</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">my_array</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.scaler.extractIthVariableData", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "qualname": "extractIthVariableData", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">n_var</span>, </span><span class=\"param\"><span class=\"n\">data_matrix</span>, </span><span class=\"param\"><span class=\"n\">variable_ordering</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.scaler.scaleDataMatrixForIthVar", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "qualname": "scaleDataMatrixForIthVar", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">n_var</span>, </span><span class=\"param\"><span class=\"n\">data_matrix</span>, </span><span class=\"param\"><span class=\"n\">variable_ordering</span>, </span><span class=\"param\"><span class=\"n\">var_scale</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.scaler.NoOpScaler", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "qualname": "NoOpScaler", "kind": "class", "doc": "<p>No op implementation</p>\n", "bases": "AbstractScaler"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.scaler.NoOpScaler.preScaling", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "qualname": "NoOpScaler.preScaling", "kind": "function", "doc": "<p>Scales the snapshot matrix before performing SVD</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data_matrix</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.scaler.NoOpScaler.postScaling", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "qualname": "NoOpScaler.postScaling", "kind": "function", "doc": "<p>Scales the left singular vectors after performing SVD</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data_matrix</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.scaler.VectorScaler", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "qualname": "VectorScaler", "kind": "class", "doc": "<p>Concrete implementation designed to scale snapshot matrices by a vector.\nFor a snapshot matrix $\\mathbf{S} \\in \\mathbb{R}^{N \\times K}$, the VectorScaler\naccepts in a scaling vector $\\mathbf{v} \\in \\mathbb{R}^N$, and scales by\n$$\\mathbf{S}^* = \\mathrm{diag}(\\mathbf{v})^{-1} \\mathbf{S}$$\nbefore performing POD (i.e., POD is performed on $\\mathbf{S}^*$). After POD is performed, the bases\nare post-scaled by $$\\boldsymbol \\Phi = \\mathrm{diag}(\\mathbf{v}) \\mathbf{U}$$</p>\n\n<p><strong>Note that scaling can cause bases to not be orthonormal; we do not recommend using scalers with the NoOpOrthonormalizer</strong></p>\n", "bases": "AbstractScaler"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.scaler.VectorScaler.__init__", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "qualname": "VectorScaler.__init__", "kind": "function", "doc": "<p>Inputs: scaling_vector: array containing the scaling vector for each row in the snapshot matrix</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">scaling_vector</span></span>)</span>"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.scaler.VectorScaler.preScaling", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "qualname": "VectorScaler.preScaling", "kind": "function", "doc": "<p>Scales the snapshot matrix before performing SVD</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data_matrix</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.scaler.VectorScaler.postScaling", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "qualname": "VectorScaler.postScaling", "kind": "function", "doc": "<p>Scales the left singular vectors after performing SVD</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data_matrix</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.scaler.VariableScaler", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "qualname": "VariableScaler", "kind": "class", "doc": "<p>Concrete implementation designed for snapshot matrices involving multiple state variables.\nThis scaler will scales each variable based on</p>\n\n<ul>\n<li>max-abs scaling: for the $i$th state variable $u_i$, we will compute the scaling as $s_i = \\mathrm{max}( \\mathrm{abs}( S_i ) )$, where $S_i$ denotes the snapshot matrix of the $i$th variable.</li>\n<li>mean abs: for the $i$th state variable $u_i$, we will compute the scaling as $s_i = \\mathrm{mean}( \\mathrm{abs}( S_i ) )$, where $S_i$ denotes the snapshot matrix of the $i$th variable.</li>\n<li>variance: for the $i$th state variable $u_i$, we will compute the scaling as $s_i = \\mathrm{std}( S_i ) $, where $S_i$ denotes the snapshot matrix of the $i$th variable.</li>\n</ul>\n\n<p><strong>This class requires you to specify variable ordering (either 'F' or 'C')</strong>\nFor a state with variables $u,v,w$ defined at $n$ discrete points, these orderings are</p>\n\n<p><strong>Order F variable ordering: $[u_1,v_1,w_1,u_2,v_2,w_2,...,u_n,v_n,w_n]$</strong></p>\n\n<p><strong>Order C variable ordering: $[u_1,u_2,...,u_n,v_1,...]$</strong></p>\n", "bases": "AbstractScaler"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.scaler.VariableScaler.__init__", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "qualname": "VariableScaler.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">scaling_type</span>, </span><span class=\"param\"><span class=\"n\">variable_ordering</span>, </span><span class=\"param\"><span class=\"n\">n_var</span></span>)</span>"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.scaler.VariableScaler.have_scales_been_initialized", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "qualname": "VariableScaler.have_scales_been_initialized", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.scaler.VariableScaler.initializeScalings", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "qualname": "VariableScaler.initializeScalings", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data_matrix</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.scaler.VariableScaler.preScaling", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "qualname": "VariableScaler.preScaling", "kind": "function", "doc": "<p>Scales the snapshot matrix before performing SVD</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data_matrix</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.scaler.VariableScaler.postScaling", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "qualname": "VariableScaler.postScaling", "kind": "function", "doc": "<p>Scales the left singular vectors after performing SVD</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data_matrix</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.scaler.VariableAndVectorScaler", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "qualname": "VariableAndVectorScaler", "kind": "class", "doc": "<p>Concrete implementation designed to scale snapshot matrices involving multiple state variables by both the variable magnitudes and an additional vector.\nThis is particularly useful when wishing to perform POD for, e.g., a finite volume method where we want to scale by the cell volumes as well as the variable\nmagnitudes. This implementation combines the VectorScaler and VariableScaler classes</p>\n", "bases": "AbstractScaler"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.scaler.VariableAndVectorScaler.__init__", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "qualname": "VariableAndVectorScaler.__init__", "kind": "function", "doc": "<p>Inputs: scaling_vector: array containing the scaling vector for each row in the snapshot matrix\nscaling_type: 'max_abs','mean_abs', or 'variance'\nvariable_ordering: 'F' or 'C'</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">scaling_vector</span>, </span><span class=\"param\"><span class=\"n\">scaling_type</span>, </span><span class=\"param\"><span class=\"n\">variable_ordering</span>, </span><span class=\"param\"><span class=\"n\">n_var</span></span>)</span>"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.scaler.VariableAndVectorScaler.preScaling", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "qualname": "VariableAndVectorScaler.preScaling", "kind": "function", "doc": "<p>Scales the snapshot matrix before performing SVD</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data_matrix</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.scaler.VariableAndVectorScaler.postScaling", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.scaler", "qualname": "VariableAndVectorScaler.postScaling", "kind": "function", "doc": "<p>Scales the left singular vectors after performing SVD</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data_matrix</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.shifter", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.shifter", "kind": "module", "doc": "<p>The Shifter class is used to create an affine offset in a trial space.</p>\n\n<p><em>What is a shift vector, and why would I use it?</em> In ROMs, we restrict a state to belong to a low-dimensional affine trial space,\n$$\\mathbf{u} \\approx \\tilde{\\mathbf{u}} \\in \\mathcal{V}$$\nwhere\n$\\mathcal{V} \\equiv \\mathrm{range}(\\boldsymbol \\Phi) + \\mathbf{u}_{\\mathrm{shift}}$\nis the trial space. Here $\\mathbf{u}_{\\mathrm{shift}}$ defines an affine offset.\nAffine offsets can be useful for a variety of reasons, including satisfying boundary conditions, and satisfying initial conditions.</p>\n\n<p>The Shifter class encapsulates the affine offset.</p>\n"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.shifter.AbstractShifter", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.shifter", "qualname": "AbstractShifter", "kind": "class", "doc": "<p>Abstract implmentation</p>\n", "bases": "abc.ABC"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.shifter.NoOpShifter", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.shifter", "qualname": "NoOpShifter", "kind": "class", "doc": "<p>No op implementation</p>\n", "bases": "AbstractShifter"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.shifter.ConstantShifter", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.shifter", "qualname": "ConstantShifter", "kind": "class", "doc": "<p>Shifts by a constant value</p>\n", "bases": "AbstractShifter"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.shifter.ConstantShifter.__init__", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.shifter", "qualname": "ConstantShifter.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shift_value</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span>)</span>"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.shifter.VectorShifter", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.shifter", "qualname": "VectorShifter", "kind": "class", "doc": "<p>Shifts by a user-input vector</p>\n", "bases": "AbstractShifter"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.shifter.VectorShifter.__init__", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.shifter", "qualname": "VectorShifter.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shift_vector</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span>)</span>"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.shifter.AverageShifter", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.shifter", "qualname": "AverageShifter", "kind": "class", "doc": "<p>Shifts by the average of a data matrix</p>\n", "bases": "AbstractShifter"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.shifter.FirstVecShifter", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.shifter", "qualname": "FirstVecShifter", "kind": "class", "doc": "<p>Shifts by the first vector of a data matrix</p>\n", "bases": "AbstractShifter"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.splitter", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.splitter", "kind": "module", "doc": "<p>The Splitter class is used to \"split\" a snapshot matrix before constructing the trial space.</p>\n\n<p><em>What do we mean by splitting a trial space, and why do it?</em>\nTrial space splitting can be important for vector-valued equations where there are multiple state variables. As an example, we could consider the compressible Euler equations in one dimension in which case the spatially continuous (conserved) variable set is\n$$\\boldsymbol u(x) = \\begin{bmatrix} \\rho(x) &amp;  \\rho u (x)&amp; \\rho E(x) \\end{bmatrix}^T.$$\nThere are several ways of constructing ROMs of vector-valued systems. In one approach, we simply stack all of our degrees of freedom and create a global basis. Mathematically, this comprises constructing a basis function that looks as follows\n$$\n\\boldsymbol \\Phi(x) = \\begin{bmatrix}\n\\Phi_{1}^{\\rho}(x) &amp; \\Phi_{2}^{\\rho }(x) &amp; \\cdots &amp; \\Phi_{K}^{\\rho}(x) \\\\\n\\Phi_{1}^{\\rho u}(x) &amp; \\Phi_{2}^{\\rho u }(x) &amp; \\cdots &amp; \\Phi_{K}^{\\rho u}(x) \\\\\n\\Phi_{1}^{\\rho E}(x) &amp; \\Phi_{2}^{\\rho E }(x) &amp; \\cdots &amp; \\Phi_{K}^{\\rho E}(x) \\\n\\end{bmatrix},\n$$\nand the state is approximated by\n$$\\tilde{\\boldsymbol u}(x) = \\sum_{i=1}^{K} \\Phi_i(x) \\hat{\\boldsymbol u}(t).$$\nWith this representation, the different state variables share generalized coordinates $\\hat{\\boldsymbol u}(t)$.</p>\n\n<p>An alternative approach is to ensure that each state variable is linearly independent of the other by employing a block basis. With this approach, this comprises a basis function that looks like\n$$\n\\boldsymbol \\Phi(x) = \\begin{bmatrix}\n\\Phi_{1}^{\\rho}(x) &amp;  0                     &amp;  0  &amp; \\Phi_{2}^{\\rho }(x) &amp; \\cdots \\\\\n 0                   &amp; \\Phi_{1}^{\\rho u }(x) &amp;  0 &amp; 0 &amp; \\cdots \\\\\n 0                   &amp; 0                      &amp; \\Phi_{1}^{\\rho E}(x) &amp; 0 &amp; \\cdots \\\n\\end{bmatrix}.\n$$\nThis \"split\" representation can be particularly advantageous for problems where different state variables span numerous orders of magnitude.</p>\n\n<p>The splitting class encapsulates this functionality. We note that the splitter is <strong>applied to the snapshot matrix before POD is performed</strong>.</p>\n"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.splitter.AbstractSplitter", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.splitter", "qualname": "AbstractSplitter", "kind": "class", "doc": "<p>Abstract class for a splitter</p>\n", "bases": "abc.ABC"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.splitter.NoOpSplitter", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.splitter", "qualname": "NoOpSplitter", "kind": "class", "doc": "<p>Concrete no-op implementation</p>\n", "bases": "AbstractSplitter"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.splitter.BlockSplitter", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.splitter", "qualname": "BlockSplitter", "kind": "class", "doc": "<p>Splits a data matrix into blocks defined by a list, e.g., for our Euler equation example above, we could set blocks = [[0,1],[2]] which\nwould result in\n$$\n\\boldsymbol \\Phi(x) = \\begin{bmatrix}\n\\Phi_{1}^{\\rho}(x)   &amp;  0 &amp; \\Phi_{2}^{\\rho}(x) &amp;  0 &amp; \\cdots  \\\\\n\\Phi_{1}^{\\rho u}(x) &amp;  0 &amp; \\Phi_{2}^{\\rho u}(x) &amp; 0 &amp; \\cdots \\\\\n0                      &amp; \\Phi_{1}^{\\rho E }(x) &amp; 0 &amp; \\Phi_{2}^{\\rho E }(x) &amp; \\cdots \\\n\\end{bmatrix}.\n$$</p>\n\n<p><strong>Notes on variable ordering</strong>\n<strong>Order F variable ordering: $[u_1,v_1,w_1,u_2,v_2,w_2,...,u_n,v_n,w_n]$</strong></p>\n\n<p><strong>Order C variable ordering: $[u_1,u_2,...,u_n,v_1,...]$</strong></p>\n", "bases": "AbstractSplitter"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.splitter.BlockSplitter.__init__", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.splitter", "qualname": "BlockSplitter.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">blocks</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">n_var</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">variable_ordering</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span>)</span>"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.splitter.getDataMatrixForIthVar", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.splitter", "qualname": "getDataMatrixForIthVar", "kind": "function", "doc": "<p>helper function to split data</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">n_var</span>, </span><span class=\"param\"><span class=\"n\">data_matrix</span>, </span><span class=\"param\"><span class=\"n\">variable_ordering</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.truncater", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.truncater", "kind": "module", "doc": "<p>Constructing a basis via POD typically entails computing the SVD of a snapshot matrix,\n$$ \\mathbf{U} ,\\mathbf{\\Sigma} = \\mathrm{svd}(\\mathbf{S})$$\nand then selecting the first $K$ left singular vectors (i.e., the first $K$ columns of $\\mathbf{U}$). Typically,\n$K$ is determined through the decay of the singular values.</p>\n\n<p>The truncater class is desined to truncate a basis.\nWe provide concrete implementations that truncate based on a specified number of basis vectors and\nthe decay of the singular values</p>\n"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.truncater.AbstractTruncater", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.truncater", "qualname": "AbstractTruncater", "kind": "class", "doc": "<p>Abstract implementation</p>\n", "bases": "abc.ABC"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.truncater.NoOpTruncater", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.truncater", "qualname": "NoOpTruncater", "kind": "class", "doc": "<p>No op implementation</p>\n", "bases": "AbstractTruncater"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.truncater.BasisSizeTruncater", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.truncater", "qualname": "BasisSizeTruncater", "kind": "class", "doc": "<p>Truncates to a specified number of singular vectors, as specified in the constructor</p>\n", "bases": "AbstractTruncater"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.truncater.BasisSizeTruncater.__init__", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.truncater", "qualname": "BasisSizeTruncater.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis_dimension</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span>)</span>"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.truncater.EnergyTruncater", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.truncater", "qualname": "EnergyTruncater", "kind": "class", "doc": "<p>Truncates based on the decay of singular values, i.e., will define $K$ to be the number of singular values\nsuch that the cumulative energy retained is greater than some threshold.</p>\n", "bases": "AbstractTruncater"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.truncater.EnergyTruncater.__init__", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.truncater", "qualname": "EnergyTruncater.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span>)</span>"}, {"fullname": "rom-tools-and-workflows.romtools.trial_space_utils.truncater.EnergyTruncater.energy_threshold_", "modulename": "rom-tools-and-workflows.romtools.trial_space_utils.truncater", "qualname": "EnergyTruncater.energy_threshold_", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "rom-tools-and-workflows.romtools.workflows", "modulename": "rom-tools-and-workflows.romtools.workflows", "kind": "module", "doc": "<p>The workflows module contains all of our \"outerloop\" workflows used for ROM construction and ROM exploitation. We currently support:</p>\n\n<ul>\n<li>Greedy sampling for construction of reduced-basis ROMs</li>\n<li>Random sampling for model exploitation</li>\n<li>Coupling classes to Dakota for \n<ul>\n<li>Random sampling</li>\n</ul></li>\n</ul>\n"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.dakota", "modulename": "rom-tools-and-workflows.romtools.workflows.dakota", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.dakota.sampling", "modulename": "rom-tools-and-workflows.romtools.workflows.dakota.sampling", "kind": "module", "doc": "<p>This module implements the abstract class and function required to \ncouple a model to Dakota for use in random sampling. To couple to Dakota, \na user should</p>\n\n<ol>\n<li>Complete the DakotaSamplingCouplerBase for their application of interest</li>\n<li>Use the \"run_dakota_sampling\" function as their Dakota analysis driver</li>\n</ol>\n"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.dakota.sampling.DakotaSamplingCouplerBase", "modulename": "rom-tools-and-workflows.romtools.workflows.dakota.sampling", "qualname": "DakotaSamplingCouplerBase", "kind": "class", "doc": "<p>Abstract class implementation</p>\n", "bases": "abc.ABC"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.dakota.sampling.DakotaSamplingCouplerBase.copyTemplateFile", "modulename": "rom-tools-and-workflows.romtools.workflows.dakota.sampling", "qualname": "DakotaSamplingCouplerBase.copyTemplateFile", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.dakota.sampling.DakotaSamplingCouplerBase.setParametersInInput", "modulename": "rom-tools-and-workflows.romtools.workflows.dakota.sampling", "qualname": "DakotaSamplingCouplerBase.setParametersInInput", "kind": "function", "doc": "<p>This function is called from a run directory. It needs to update a \ntemplate file with parameter values defined in parameter_sample. \nFor example, this could be done with dprepro</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">parameter_sample</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.dakota.sampling.DakotaSamplingCouplerBase.runModel", "modulename": "rom-tools-and-workflows.romtools.workflows.dakota.sampling", "qualname": "DakotaSamplingCouplerBase.runModel", "kind": "function", "doc": "<p>This function is called from a run directory. It needs to execute our model.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.dakota.sampling.DakotaSamplingCouplerBase.computeQoiAndSaveToFile", "modulename": "rom-tools-and-workflows.romtools.workflows.dakota.sampling", "qualname": "DakotaSamplingCouplerBase.computeQoiAndSaveToFile", "kind": "function", "doc": "<p>This function should compute a QoI and save to file. The output file should match what is specified in the\nDakota input script</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.dakota.sampling.run_dakota_sampling", "modulename": "rom-tools-and-workflows.romtools.workflows.dakota.sampling", "qualname": "run_dakota_sampling", "kind": "function", "doc": "<p>Basic Dakota analysis driver leveraging the DakotaSamplingCoupler API</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">DakotaSamplingCoupler</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base", "kind": "module", "doc": "<p>The GreedyCoupler is the primary way we interface with an application to perform \ngreedy sampling. We can leverage <strong>any</strong> class meeting this API to perform greedy.</p>\n\n<p>We provide a partially concrete implementation of the greedy class. Our implementation \nestablishes aspects such as directory structure, but leaves the definition of, e.g., how \na ROM should be run or how the input file should be modified abstract.</p>\n"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base.GreedyCouplerBase", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base", "qualname": "GreedyCouplerBase", "kind": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "abc.ABC"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base.GreedyCouplerBase.getRomInputFileName", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base", "qualname": "GreedyCouplerBase.getRomInputFileName", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base.GreedyCouplerBase.getFomInputFileName", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base", "qualname": "GreedyCouplerBase.getFomInputFileName", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base.GreedyCouplerBase.getFomDirectoryBaseName", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base", "qualname": "GreedyCouplerBase.getFomDirectoryBaseName", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base.GreedyCouplerBase.getRomDirectoryBaseName", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base", "qualname": "GreedyCouplerBase.getRomDirectoryBaseName", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base.GreedyCouplerBase.getBaseDirectory", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base", "qualname": "GreedyCouplerBase.getBaseDirectory", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base.GreedyCouplerBase.getWorkDirectoryBaseName", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base", "qualname": "GreedyCouplerBase.getWorkDirectoryBaseName", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base.GreedyCouplerBase.createFomAndRomCases", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base", "qualname": "GreedyCouplerBase.createFomAndRomCases", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">starting_sample_no</span>, </span><span class=\"param\"><span class=\"n\">parameter_samples</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base.GreedyCouplerBase.computeError", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base", "qualname": "GreedyCouplerBase.computeError", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">rom_directory</span>, </span><span class=\"param\"><span class=\"n\">fom_directory</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base.GreedyCouplerBase.setParametersInRomInput", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base", "qualname": "GreedyCouplerBase.setParametersInRomInput", "kind": "function", "doc": "<p>This function is called from a run directory. It needs to update a \ntemplate ROM file with parameter values defined in parameter_sample. \nFor example, this could be done with dprepro</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">filename</span>, </span><span class=\"param\"><span class=\"n\">parameter_sample</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base.GreedyCouplerBase.setParametersInFomInput", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base", "qualname": "GreedyCouplerBase.setParametersInFomInput", "kind": "function", "doc": "<p>This function is called from a run directory. It needs to update a \ntemplate FOM file with parameter values defined in parameter_sample. \nFor example, this could be done with dprepro</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">filename</span>, </span><span class=\"param\"><span class=\"n\">parameter_sample</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base.GreedyCouplerBase.computeQoi", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base", "qualname": "GreedyCouplerBase.computeQoi", "kind": "function", "doc": "<p>This function needs to return a scalar qoi.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base.GreedyCouplerBase.computeErrorIndicator", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base", "qualname": "GreedyCouplerBase.computeErrorIndicator", "kind": "function", "doc": "<p>This function is called from a run directory. It needs to return a scalar error estimate.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base.GreedyCouplerBase.runRom", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base", "qualname": "GreedyCouplerBase.runRom", "kind": "function", "doc": "<p>This function is called from a run directory. It needs to execute a ROM.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">filename</span>, </span><span class=\"param\"><span class=\"n\">parameter_values</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base.GreedyCouplerBase.runFom", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base", "qualname": "GreedyCouplerBase.runFom", "kind": "function", "doc": "<p>This function is called from a run directory. It needs to execute a FOM.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">filename</span>, </span><span class=\"param\"><span class=\"n\">parameter_values</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base.GreedyCouplerBase.createTrialSpace", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base", "qualname": "GreedyCouplerBase.createTrialSpace", "kind": "function", "doc": "<p>This function is called the base directory. Given the FOM runs as defined by training_sample_indices, it needs to compute and save a trial space</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">training_sample_indices</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base.GreedyCouplerBase.getParameterSpace", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy.greedy_coupler_base", "qualname": "GreedyCouplerBase.getParameterSpace", "kind": "function", "doc": "<p>This function should return a ParameterSpace class defining our parameter space.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy.run_greedy", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy.run_greedy", "kind": "module", "doc": "<p>The greedy procedure iteratively constructs a reduced basis ROM until it reaches a desired tolerance. The algorithm is as follows:</p>\n\n<ol>\n<li>We generate a parameter training set, $\\mathcal{D}_{\\mathrm{train}}, |\\mathcal{D}_{\\mathrm{train}} | = N_{\\mathrm{train}}$</li>\n<li>We select an initial sample, $\\mu_1 \\in \\mathcal{D}_{\\mathrm{train}} \\text{ and set } \\mathcal{D}_{\\mathrm{train}}=\\mathcal{D}_{\\mathrm{train}} - {\\mu_1}$</li>\n<li>We then solve the FOM to obtain the solution, $\\mathbf{u}(\\mu_1)$.</li>\n<li>We select a second sample, $\\mu_2 \\in \\mathcal{D}_{\\mathrm{train}} \\text{ and set } \\mathcal{D}_{\\mathrm{train}}=\\mathcal{D}_{\\mathrm{train}} - {\\mu_2}$</li>\n<li>We then solve the FOM to obtain the solution, $\\mathbf{u}(\\mu_2)$.</li>\n<li>We employ the first two solutions to compute the trial space, e.g.,\n$$\\boldsymbol \\Phi = \\mathrm{orthogonalize}(\\mathbf{u}(\\mu_2)) -  \\mathbf{u}_{\\mathrm{shift}}, \\; \\mathbf{u}_{\\mathrm{shift}} = \\mathbf{u}(\\mu_1)$$</li>\n<li>We then solve the resulting ROM for the remaining parameter samples $\\mathcal{D}_{\\mathrm{train}}$ to generate approximate solutions $\\mathbf{u}(\\mu), \\mu \\in \\mathcal{D}_{\\mathrm{train}}$</li>\n<li>For each ROM solution $\\mathbf{u}(\\mu), \\mu \\in \\mathcal{D}_{\\mathrm{train}}$ we compuate an error estimate, $ e \\left(\\mu \\right) $</li>\n<li>If the maximum error estimate is less than some tolerance, we exit the algorithm. If not, we:\n<ul>\n<li>Set $ \\mu^* = \\underset{ \\mu \\in \\mathcal{D}_{\\mathrm{train}} }{ \\mathrm{arg\\; max} } \\; e \\left(\\mu \\right) $</li>\n<li>Remove $\\mu^{*}$ from the training set, $\\mathcal{D}_{\\mathrm{train}}=\\mathcal{D}_{\\mathrm{train}} - {\\mu^{*}}$</li>\n<li>Solve the FOM for $\\mathbf{u}(\\mu^{*})$</li>\n<li>Set the reduced basis to be $\\boldsymbol \\Phi = \\mathrm{orthogonalize}(\\boldsymbol \\Phi, \\mathbf{u}(\\mu^{*})) -  \\mathbf{u}_{\\mathrm{shift}}$</li>\n<li>Go back to step 6 and continue until convergence.</li>\n</ul></li>\n</ol>\n\n<p>This function implements the basic greedy workflow. In addition, we enable an adaptive\nerror estimate based on a QoI. This is based of the fact that, throughout the greedy algorithm, we have a\nhistory of error indicators as well as a set of FOM and ROM runs for the same parameter instance. We leverage this data\nto improve the error estimate. Specifically, for the max error estimates over the first $j$ iterations, $e_1,\\ldots,e_j$, we\nadditionally can access QoI errors $e^q_1,\\ldots,e^q_j$ from our FOM-ROM runs, and we define a scaling based on\n$$C = \\frac{\\sum_{i=1}^j | e^q_j| }{ \\sum_{i=1}^j | e_j | }.$$\nThe error at the $j+1$ iteration can be approximated by $C e(\\mu)$.\nThis will adaptively scale the error estimate to match the QoI error as closely as possible, which can be helpful for defining exit criterion.</p>\n"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy.run_greedy.runGreedy", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy.run_greedy", "qualname": "runGreedy", "kind": "function", "doc": "<p>Main implementation of the greedy algorithm.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">greedyCoupler</span>, </span><span class=\"param\"><span class=\"n\">tolerance</span>, </span><span class=\"param\"><span class=\"n\">testing_sample_size</span><span class=\"o\">=</span><span class=\"mi\">10</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy.run_greedy.qoi_vs_error_indicator_regressor", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy.run_greedy", "qualname": "qoi_vs_error_indicator_regressor", "kind": "class", "doc": "<p>Regressor for the scaling between QoI error and error indicator</p>\n"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy.run_greedy.qoi_vs_error_indicator_regressor.fit", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy.run_greedy", "qualname": "qoi_vs_error_indicator_regressor.fit", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.greedy.run_greedy.qoi_vs_error_indicator_regressor.predict", "modulename": "rom-tools-and-workflows.romtools.workflows.greedy.run_greedy", "qualname": "qoi_vs_error_indicator_regressor.predict", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.parameter_spaces", "modulename": "rom-tools-and-workflows.romtools.workflows.parameter_spaces", "kind": "module", "doc": "<p>Model reduction is often focused on parameterized PDEs, where $\\boldsymbol \\mu$ is the parameter set.\nThe ParameterSpace class encapsulates the notion of the parameter space.</p>\n"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.parameter_spaces.AbstractParameterSpace", "modulename": "rom-tools-and-workflows.romtools.workflows.parameter_spaces", "qualname": "AbstractParameterSpace", "kind": "class", "doc": "<p>Abstract implementation</p>\n", "bases": "abc.ABC"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.parameter_spaces.AbstractParameterSpace.getNames", "modulename": "rom-tools-and-workflows.romtools.workflows.parameter_spaces", "qualname": "AbstractParameterSpace.getNames", "kind": "function", "doc": "<p>return a list of parameter names</p>\n\n<h1 id=\"eg-sigmabeta\">e.g., ['sigma','beta',...]</h1>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.parameter_spaces.AbstractParameterSpace.getDimensionality", "modulename": "rom-tools-and-workflows.romtools.workflows.parameter_spaces", "qualname": "AbstractParameterSpace.getDimensionality", "kind": "function", "doc": "<p>returns an integer for the size\nof the parameter domain</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.parameter_spaces.AbstractParameterSpace.generateSamples", "modulename": "rom-tools-and-workflows.romtools.workflows.parameter_spaces", "qualname": "AbstractParameterSpace.generateSamples", "kind": "function", "doc": "<p>generates and returns number of parameter samples</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">number_of_samples</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.parameter_spaces.UniformParameterSpace", "modulename": "rom-tools-and-workflows.romtools.workflows.parameter_spaces", "qualname": "UniformParameterSpace", "kind": "class", "doc": "<p>Concrete implementation for a uniform parameter space with random sampling</p>\n", "bases": "AbstractParameterSpace"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.parameter_spaces.UniformParameterSpace.__init__", "modulename": "rom-tools-and-workflows.romtools.workflows.parameter_spaces", "qualname": "UniformParameterSpace.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">parameter_names</span>, </span><span class=\"param\"><span class=\"n\">lower_bounds</span>, </span><span class=\"param\"><span class=\"n\">upper_bounds</span></span>)</span>"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.parameter_spaces.UniformParameterSpace.getNames", "modulename": "rom-tools-and-workflows.romtools.workflows.parameter_spaces", "qualname": "UniformParameterSpace.getNames", "kind": "function", "doc": "<p>return a list of parameter names</p>\n\n<h1 id=\"eg-sigmabeta\">e.g., ['sigma','beta',...]</h1>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.parameter_spaces.UniformParameterSpace.getDimensionality", "modulename": "rom-tools-and-workflows.romtools.workflows.parameter_spaces", "qualname": "UniformParameterSpace.getDimensionality", "kind": "function", "doc": "<p>returns an integer for the size\nof the parameter domain</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.parameter_spaces.UniformParameterSpace.generateSamples", "modulename": "rom-tools-and-workflows.romtools.workflows.parameter_spaces", "qualname": "UniformParameterSpace.generateSamples", "kind": "function", "doc": "<p>generates and returns number of parameter samples</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">number_of_samples</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.sampling", "modulename": "rom-tools-and-workflows.romtools.workflows.sampling", "kind": "module", "doc": "<p>Implementation of basic sampling workflow. Given a parameter space $\\mathcal{D}$, we draw random samples and \nrun our model for each sample.</p>\n"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.sampling.sampling", "modulename": "rom-tools-and-workflows.romtools.workflows.sampling.sampling", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.sampling.sampling.runSampling", "modulename": "rom-tools-and-workflows.romtools.workflows.sampling.sampling", "qualname": "runSampling", "kind": "function", "doc": "<p>Core algorithm</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">samplingCoupler</span>, </span><span class=\"param\"><span class=\"n\">testing_sample_size</span><span class=\"o\">=</span><span class=\"mi\">10</span>, </span><span class=\"param\"><span class=\"n\">random_seed</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.sampling.sampling_coupler_base", "modulename": "rom-tools-and-workflows.romtools.workflows.sampling.sampling_coupler_base", "kind": "module", "doc": "<p>Abstract implementation of the SamplingCoupler class. To gain access to the sampling algorithm, the user needs to \ncomplete this class for their application</p>\n"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.sampling.sampling_coupler_base.SamplingCouplerBase", "modulename": "rom-tools-and-workflows.romtools.workflows.sampling.sampling_coupler_base", "qualname": "SamplingCouplerBase", "kind": "class", "doc": "<p>Partially explicit implementation</p>\n", "bases": "abc.ABC"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.sampling.sampling_coupler_base.SamplingCouplerBase.getInputFileName", "modulename": "rom-tools-and-workflows.romtools.workflows.sampling.sampling_coupler_base", "qualname": "SamplingCouplerBase.getInputFileName", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.sampling.sampling_coupler_base.SamplingCouplerBase.getWorkDirectoryBaseName", "modulename": "rom-tools-and-workflows.romtools.workflows.sampling.sampling_coupler_base", "qualname": "SamplingCouplerBase.getWorkDirectoryBaseName", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.sampling.sampling_coupler_base.SamplingCouplerBase.getSolDirectoryBaseName", "modulename": "rom-tools-and-workflows.romtools.workflows.sampling.sampling_coupler_base", "qualname": "SamplingCouplerBase.getSolDirectoryBaseName", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.sampling.sampling_coupler_base.SamplingCouplerBase.getBaseDirectory", "modulename": "rom-tools-and-workflows.romtools.workflows.sampling.sampling_coupler_base", "qualname": "SamplingCouplerBase.getBaseDirectory", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.sampling.sampling_coupler_base.SamplingCouplerBase.createCases", "modulename": "rom-tools-and-workflows.romtools.workflows.sampling.sampling_coupler_base", "qualname": "SamplingCouplerBase.createCases", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">starting_sample_no</span>, </span><span class=\"param\"><span class=\"n\">parameter_samples</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.sampling.sampling_coupler_base.SamplingCouplerBase.setParametersInInput", "modulename": "rom-tools-and-workflows.romtools.workflows.sampling.sampling_coupler_base", "qualname": "SamplingCouplerBase.setParametersInInput", "kind": "function", "doc": "<p>This function is called from a run directory. It needs to update a \ntemplate file with parameter values defined in parameter_sample. \nFor example, this could be done with dprepro</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">filename</span>, </span><span class=\"param\"><span class=\"n\">parameter_sample</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.sampling.sampling_coupler_base.SamplingCouplerBase.runModel", "modulename": "rom-tools-and-workflows.romtools.workflows.sampling.sampling_coupler_base", "qualname": "SamplingCouplerBase.runModel", "kind": "function", "doc": "<p>This function is called from a run directory. It needs to execute our model.\nIf the model runs succesfully, return 0\nIf fails, return 1</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">filename</span>, </span><span class=\"param\"><span class=\"n\">parameter_values</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "rom-tools-and-workflows.romtools.workflows.sampling.sampling_coupler_base.SamplingCouplerBase.getParameterSpace", "modulename": "rom-tools-and-workflows.romtools.workflows.sampling.sampling_coupler_base", "qualname": "SamplingCouplerBase.getParameterSpace", "kind": "function", "doc": "<p>This function should return a ParameterSpace class defining our parameter space.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();